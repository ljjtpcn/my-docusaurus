---
slug: acm-geometry
title: 计算几何
date: 2022-06-30
authors: ljj
tags: [计算几何, ACM]
---
<!-- truncate -->

## 二维凸包

###  [圈奶牛Fencing the Cows](https://www.luogu.com.cn/problem/P2742)

```c++
// Problem: P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2742
// Memory Limit: 128 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
#define Please return
#define AC 0
#define pb push_back
#define fir first
#define sec second
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
// clang-format off
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
inline void read(int &num) {int s = 0;char ch = getchar();while (ch < '0' || ch > '9') ch = getchar();while (ch >= '0' && ch <= '9')s = (s << 3) + (s << 1) + ch - '0', ch = getchar();num = s;}
inline void read(ll &num) {ll s = 0;char ch = getchar();while (ch < '0' || ch > '9') ch = getchar();while (ch >= '0' && ch <= '9')s = (s << 3) + (s << 1) + ch - '0', ch = getchar();num = s;}
ll ksm(ll a, ll b){ll res = 1;while(b){if(b & 1)res *= a;a *= a;b >>= 1;}return res;}
ll ksm(ll a, ll b, int mod){ll res = 1;while(b){if(b & 1)res = res * a % mod;a = a * a % mod;b >>= 1;}return res;}
struct node { int x, y, cnt; };
struct cmp {bool operator()(node a, node b) { return a.cnt > b.cnt; }};
// clang-format on
const int mod = 1e9 + 7;
const int N = 1e6 + 10;

struct Point {
    double x;
    double y;
};
Point p[N]; // 存点
Point st[N]; // 模拟栈
void solve() {
    int n;
    cin >> n;
    if (n < 3) {
        cout << 0.00;
        return;
    }
    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y;
    }
    
    // Andrew 算法
    sort(p + 1, p + n + 1, [&](Point a, Point b) {
        if (a.x != b.x)
            return a.x < b.x;
        else
            return a.y < b.y;
    }); //按x，y坐标排序

    auto check = [&](Point x, Point a, Point b) {
        Point x1 = {a.x - x.x, a.y - x.y};
        Point x2 = {b.x - x.x, b.y - x.y};
        // 判断点b 在向量xa的哪一侧 右侧小于0
        return x1.x * x2.y - x2.x * x1.y < 0;  // why "<="  WA two point;
    };

    st[0] = p[1], st[1] = p[2]; // 初始栈
    int top = 1;
    for (int i = 3; i <= n; i++) { // 计算上凸包
        while (top && check(st[top - 1], st[top], p[i])) top--;
        st[++top] = p[i];
    }

    st[++top] = p[n - 1];
    for (int i = n - 2; i >= 1; i--) { // 计算下凸包
        while (top && check(st[top - 1], st[top], p[i])) top--;
        st[++top] = p[i];
    }

    // 计算凸包长度
    double ans = 0;
    for (int i = 0; i <= top - 1; i++) { // 最后会多存一个起点P1， 所以top - 1；
        Point a = st[i], b = st[i + 1];
        ans += sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));
    }
    cout << fixed << setprecision(2) << ans;
}

int main() {
    int __ = 1;
    // scanf("%d", &__);
    while (__--) {
        solve();
    }
    Please AC;
}

```

